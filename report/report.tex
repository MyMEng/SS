\documentclass[12pt, a4paper, pdflatex]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\usepackage{lipsum}
\usepackage[labelfont=bf]{caption}
\usepackage[]{algorithm2e}
\usepackage{listings}

\renewcommand{\thesubsubsection}{\thesubsection.\alph{subsubsection})} %subsubsections with letters

\usepackage{amsmath}
\usepackage{amsfonts}    % fancy maths font
\usepackage{mathrsfs}    % fancy maths font
\usepackage{dsfont}      % indocator finction
\usepackage{hyperref}
\usepackage[usenames,dvipsnames]{color}

% \newcommand{\ts}{\textsuperscript}
% \usepackage{url}

\begin{document}
\pagenumbering{gobble}% Remove page numbers

\begin{center}
    \begin{large}
    {\HRule \\[0.2cm]}
    \textsc{System exploits}
    {\HRule \\[0.3cm]}
    \end{large}

    \begin{minipage}{ 0.49\textwidth }
        \begin{flushleft}
            Kacper \textbf{Sokol}---\texttt{ks1591}---4GGK1\\
            Maciej \textbf{Kumorek}---\texttt{mk0934}---4G403\\
        \end{flushleft}
    \end{minipage}
    \begin{minipage}{ 0.49\textwidth }
        \begin{flushright}
            {COMSM1500 $|$ Systems Security\\
            Coursework: Part A---\today\\[0.3cm]}
        \end{flushright}
    \end{minipage}
\end{center}

\section{Introduction}

\subsection{Statement of contributions}

\begin{center}
\begin{tabular}{ l | p{8.5cm} | c }
  Group member ID & Contribution outline & Contribution \\
  \hline
  ks1591 & jhkljhkhkj hklhkhkljhkhjkh kjhkhjkhkj hhhhhhjkjkhhj khjgghtfyu jhgghcfgj tytyd & 50\% \\
  mk0932 & jhkljhkhkjhklh  khkljhkhjkhkjhk hjkhkjhhhh hhjkjkhhjkhjg ghtfyujhgg hcfgjtyty d & 50\% \\
\end{tabular}
\end{center}

\section{String formatting}

Our first task was to exploit program using \emph{printf} method for formatted string output in a vulnerable way. We followed instructions of lab assignment  \url{http://www.cis.syr.edu/~wedu/seed/Labs/Vulnerability/Format_String/}
and used Ubuntu 9.10 SEED for our lab set up.

In the target program provided, a \emph{printf} method was used without any format specifier, combined with the ability for users to specify input, allowed user to fabricate any format specifier for the program, i.e. instead of printing the user output in the following way:
\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=C,
  breaklines=true,
	caption=Fragment of code that would not include the vulnerability,
	label=chroot:vul
}
\begin{lstlisting}
// Get input from user
scanf("%s", &user_input);
// Print what user typed
printf("%s", user_input);
\end{lstlisting}
the \emph{printf} was used without explicitly specifying that we want to print to standard output a string.
\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=C,
  breaklines=true,
	caption=Fragment of includes the vulnerability,
	label=chroot:vul2
}
\begin{lstlisting}
// Get input from user
scanf("%s", &user_input);
// Print what user typed
printf(user_input);
\end{lstlisting}


\subsection{Exploiting the vulnerability}
Being able to specify the string format specifier allows us to use \texttt{printf} method in order to either crash a program, look up values on stack and memory and even modify content at specific memory locations with a specified value. We used the following features of \texttt{printf} specifier string:
\begin{itemize}
	\item \texttt{\%x} - prints hexadecimal value provided in the arguments list
	\item \texttt{\%s} - prints value at the current memory location from the heap provided by arguments list
	\item \texttt{\%w} - writes number of bytes written so far to the output at the current location provided by arguments list
\end{itemize}
It's important to realize that argument list for printf would be kept on the stack. Therefore we can use \texttt{printf} to traverse the stack using for instance many \texttt{\%x} in the input string.

\subsubsection{Crashing the program}
In order to crash the program it was enough to provide a string as input that contained a few \texttt{\%s}. This way values popped from the stack would be provided to the \texttt{printf} method and memory address at the locations specified by the values. At some point we would try access memory that the process couldn't access which results in a segmentation fault and a crash of the program.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=bash,
  breaklines=true,
	caption=Example of crashing the program,
	label=printf:crash
}
\begin{lstlisting}
seed@seed-desktop:~/cwk2$ ./a.out 
The variable secret's address is 0xbf8f35d8 (on stack)
The variable secret's value is 0x 9c1d008 (on heap)
secret[0]'s address is 0x 9c1d008 (on heap)
secret[1]'s address is 0x 9c1d00c (on heap)
Please enter a string
%s%s%s%s%s%s%s%s
Segmentation fault
\end{lstlisting}

\subsubsection{Printing out specified memory from heap}
In the second part of this task we wanted to be able to provide such a format specifier that would allow us to print out some specified memory location. In this example we wanted to print out value of two-element array secret. Because provided vulnerable program to exploit prints out the address of both secrets values on the heap, we know where to look for them. We need to use \texttt{\%s} format specifier to access memory location of 
\texttt{secret} array. We ask to print six values from the stack, and the next variable on the stack would contain address to the first element of secret. However, secret is on the heap, so it's not to easy to access the second element of the array. We used the fact that a user is also prompted to input the decimal integer. Hence at runtime we can see where \texttt{secret[1]} is, and provide this value to be stored in \texttt{int\_input} integer variable. Now since that value is on the stack, after poping initial 5 values, if we also add \texttt{\%s.\%s} in the format specifier string, we tell \texttt{printf} to show us memory content at next two memory locations, specified by the contents of next two values on the stack, which corresponds to \texttt{secret[1]} and \texttt{secret[0]} and in the output below we can see that U and D are printed. These two characters have ASCII values of 0x55 and 0x44 which is what we wanted.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=bash,
  breaklines=true,
	caption=Example of printing out memory,
	label=printf:crash
}
\begin{lstlisting}
seed@seed-desktop:~/cwk2$ ./vul
The variable secret’s address is 0xbf8b258c (on stack)
The variable secret’s value is 0x 95fd008 (on heap)
secret[0]’s address is 0x 95fd008 (on heap)
secret[1]’s address is 0x 95fd00c (on heap)
Please enter a decimal integer
157274124
Please enter a string
%x.%x.%x.%x.%x.%s.%s   
bf8b2590.bf8b2610.bf8b2604.0.0.U.D
The original secrets: 0x44 -- 0x55
The new secrets:      0x44 -- 0x55
\end{lstlisting}

\subsubsection{Changing the value of \texttt{secret[1]}}

\subsubsection{Changing the value of \texttt{secret[1]} to a pre-determined value}




\RestyleAlgo{boxed}
\SetAlCapSkip{1em}
\LinesNumbered
\SetCommentSty{mycommfont}

\vspace{2cm}


\begin{algorithm}[h]
  \KwData{Data stream $...x_t, x_{t+1}, x_{t+2}, ...$;number of initialization points $T$; reservoir size $r$; fit threshold $\epsilon$.}

  \tcc{Initialization}
  $m$ $\leftarrow$ APModel($x_1, ..., x_T$)\;
  $Reservoir$ $\leftarrow$ \{\}\;

  \tcc{Receiving data}
  \For{$t > T$}{
  Compute $e_i =$ nearest exemplar to $x_t$ \;

  \uIf{$d\left( x_t, e_i \right) < \epsilon$}{Update model $m$ \;}
  \Else{$Reservoir$ $\leftarrow$ $x_t$\;}

  Rebuild Trigger $\leftarrow$ ( $\left\vert{Reservoir}\right\vert > r$ || Change Point Detection on input stream )\;

  \If{Rebuild Trigger}{
    Rebuild model $m$\;
    $Reservoir$ $\leftarrow$ \{\}\;
  }

    \caption{Streaming Affinity Propagation Clustering Algorithm.\label{alg:APC}}
    }
\end{algorithm}
\vspace{1cm}

\subsection{And the code looks like this...}
\vspace{1em}
\lstset{
  captionpos=b,
  frame=single,
  breaklines=true,
  emph={module, import, create, schema, as, @Name, @Description, select, from, win:time},
  emphstyle={\color{red}\bfseries},
  caption=EPL file example.,
  label=lst:EPL
}
\begin{lstlisting}
module
  SpringfieldNuclearPowerPlant.engine.ExternalFeatureExtractor;

import
  featureExtractors.FeatureExtractor;

create schema SinTick  as randomGenerators.Sine;

@Name('Basic---Statistics')
@Description('Extract basic signal statistics to features')
select
avg(current) as F1,
stddev(current) as F2,
from SinTick.win:time(60 sec);
\end{lstlisting}


\section{\texttt{chroot} vulnerability}
\subsection{Understanding how \texttt{chroot} works}
\subsubsection{Symbolic link}
It is \emph{not} possible to follow symbolic link pointing outside of \texttt{chroot} jail.\\
Symbolic link uses absolute or relative path to given fail, hence once in jail this relative path is not valid any-more.

\subsubsection{Hard link}
It \emph{is} possible to follow hard link pointing outside of \texttt{chroot} jail.\\
Hard links are used all over the operating system to point to given location in file-system. Therefore regardless of jail the link always points to the same location in file-system.

\subsubsection{File descriptors}


\subsubsection{Command vs.\ system call}

\subsection{Abusing unconstrained \texttt{chroot}}
\subsubsection{\texttt{set-UID} in jail}
\emph{Set-root-UID} programs can be run inside \texttt{chroot} jail.

\subsubsection{Getting root with \texttt{su}}
It is possible to gain root privileges using \texttt{/tmp/su}

\subsubsection{Preserve root privileges after exiting jail}

\subsection{Breaking out of a \texttt{chroot} jail}
\subsubsection{\texttt{cd ..} out of jail}

\subsubsection{Killing process from within the jail}
\vspace{1em}
\lstset{
  captionpos=b,
  frame=single,
  language=bash,
  breaklines=true,
  caption=Kill processes outside of chroot jail.,
  label=chroot:kill
}
\begin{lstlisting}
#!/bin/bash
i="1"
while [ $i -lt 10000 ]
do
echo $i
kill $i
i=$[$i+1]
done
\end{lstlisting}

\subsubsection{Controlling processes with \texttt{ptrace()}}
Just do loop form 1 to 10,000 with ptrace(\_option\_, i)\\
Option can be: 

\subsection{Securing \texttt{chroot}}

\section{Buffer overflow}
\lipsum[3]

\section{Conclusions}

\section{References?}

\end{document}
